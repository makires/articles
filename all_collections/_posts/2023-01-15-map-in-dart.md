---
layout: post
title: Словарь в Dart, он же Map
date: 2023-01-15
categories: ["dart"]
---

Здесь мы рассмотрим базовые возможности словаря как структуры данных, и пробежимся по основным более глубоким концепциям.

## Синтаксис

В Dart словари(они же Map) - это структура данных (она же - встроенная в язык коллекция), которая хранит в себе пару в виде ключ `key` и значение `value`. 
Чтобы создать словарь  необходимо указать, какой тип данных будет у ключа и значения:

```dart
final Map<String, int> emptyMap = {};
```

Более читаемым вариантом будет перенести дженерик (угловые скобки `<String, int>`) в правую сторону выражения. Но код делает то же самое.
```dart
final emptyMap = Map<String, int> {};
```

Обратите внимание, что если вы создатите словарь без указания типа, по умолчанию Dart будет думать, что это словарь с типом `Map<dynamic, dynamic>`. Хотя синтаксис с фигурнми скобками также используется и при создании множества Set.
```dart
final empty = {};
// Map<dynamic, dynamic>
final emptySet = <String>{};
```

Инициализировать словарь можно также с помощью непосредственного указания ключа и значения. Данный способ называется `map literal`.

```dart
final literalMap = {
	'one': 1,
	'two' : 2,
	'three' : 3,
};
```

Обратите внимание, что при таком варианте создания словаря указывать тип данных явным образом нет необходимости, потому что Dart распознает этот тип. Такая возможность языка называется `inference`.  В случае со словарем `literalMap` тип будет `Map<String, int>`.

Ключ `key` и значение `value` должны быть разделены между собой двоеточием `:`, а названия ключей должны быть уникальными в словаре и повторяться не могут. А вот значения могут повторяться. то есть быть одинаковыми.

## Операции над словарем

**Доступ к значению по ключу** осуществляется с помощью квадратных скобок (subscript notation)
```dart
final firstNumber = literalMap['one'];
```
Поскольку значение, которое возвращает словарь через `subscript notation`, может отсутствовать, то присуствует вероятность возврата null. Поэтому доступ к методам этого типа данных будет осуществляться с помощью вопросительного знака (в терминологии Swift это опциональное значение):
```dart
print(firstNumber?.isEven);
```
**Добавление элемента в словарь** осуществляется через создание нового ключа, которого еще нет в словаре и присваивание ему значения:
```dart
literalMap['five'] = 5;
```

**Обновление элемента** произойдет, если вы используете уже имеющийся в словаре ключ и присвоите ему новое значение.

**Удаление элемента из словаря** можно сделать с помощью метода `remove`, указав название ключа:
```dart
literalMap.remove('five');
```

**Проверка на ключ или значение**
```dart
print(literalMap.containsValue(5));
print(literalMap.containsKey('one'));
```

### А теперь более интересные вещи.

Добавление, обновление и удаление из словаря достаточно быстрая операция. Также быстрой операцией является проверка на наличие по ключу `containsKey()`. А вот проверка по значению может оказаться потенциально медленной, потому что Dart  придется обойти все возможные значения словаря(а их может оказаться ооочень много). Но это предупреждение справедливо для огромных коллекций данных.

В отличе от массива или множетсва, по словарю пройтись циклом `for` не удастся, посколько это не итерируемый объект (`Iterable` - это тип данных в котором можно передвигаться по элементам последовательно). Подробнее про `Iterable` можно будет почитать [здесь](./another-page.html).

Поэтому для таких целей существует несколько решений.
Пройтись циклом `for` по ключам, и по значениям
```dart
for (var key in literalMap.keys) {
	print(literalMap[key]);
}

for (final entry in literalMap.entries) {
	print(entry.key);
	print(entry.value);
}
```
#### Теперь копнём еще глубже.

Когда вы **добавляете новую пару ключ-значение**, то у вас нет никакой гарантии, что элементы будут упорядочены, однако под капотом Дарт по умолчанию использует _LinkedHashMap_, что обеспечивает гарантию упорядоченности элемента, которые вставляются в Словарь. 

Обратите внимание, это не означает, что элементы в нем упорядочены. Это говорит о том, что словарь по-прежнему является _не упорядоченной коллекцией_, однако из-за того, что по умолчанию Dart использует словарь с _LinkedHashMap_, то вы получаете упорядоченность в добавлении последнего элемента. 
В отличие от словаря с _HashMap_, такого порядка нет. Такой словарь надо импортировать самостоятельно. 

Также, в отличие от массива, словарь не несет накладных расходов, связанных со **вставкой нового элемента в словарь**. Поскольку во время вставки _элементы сдвигать не приходится_. Поэтому вставка в словарь - это быстрая операция и занимает постоянное время О(1).

**Поиск в словаре** тоже имеет постоянное время О(1), что значительно быстрее, чем обходить весь массив по элементу О(n), как например в массиве.
